/**
 * =====================================
 * z_jsonParseSupport2 ( functionId ; req ; private ; res ; step )
 *
 * PURPOSE:
 *		Supporting code for native json parsing functions.
 *		mid-level/object walking/array walking
 *
 * PARAMETERS:
 *		functionId = numeric code for function to run, in range of 200 - 299
 *			210		ParseArrayFindEnd
 *			211		ParseArrayFindValue
 *			212		ParseArrayGetKeyList
 *			220		ParseObjectFindEnd
 *			221		ParseObjectFindValue
 *			222		ParseObjectGetKeyList
 *		req = requested data (if any)
 *		private = private data, likely sent to recursive calls of a function
 *		res = response
 *		step = current state of a recursive function
 *
 * DEPENDENCIES:
 *		none
 *
 * HISTORY:
 *		CREATED on 2015-APR-10 by Daniel Smith dansmith65@gmail.com
 *
 * =====================================
 */

/* logging start disabled
Let ( [
	uuid = Get ( UUID ) ;
	~! = LogWriterMemoryCreateEntry (
		"z_jsonParseSupport2 "
			& " [functionId:" & functionId & "]"
			& " [uuid:" & uuid & "]"
			& " [req:" & req & "]"
			& " [private:" & private & "]"
			& " [res:" & res & "]"
			& " [step:" & step & "]"
	)
] ;
disabled logging end */
Case (
	
	
	functionId = 210 /* ParseArrayFindEnd */
		or functionId = 211 /* ParseArrayFindValue */
		or functionId = 212 /* ParseArrayGetKeyList */
	;
	/**
	 * =====================================================================
	 * ARRAY WALKING FUNCTIONS
	 *
	 * ParseArrayFindEnd: Move pointer to the end of the array.
	 * ParseArrayFindValue: Move pointer to the start of the value for a specified index.
	 * ParseArrayGetKeyList: Get a list of top-level indexes in an array.
	 *
	 * parameters:
	 *		req = index to find for ParseArrayFindValue, not used for others
	 *		private = current array index
	 *
	 * returns:
	 *		ParseArrayFindEnd: Empty string.
	 *		ParseArrayFindValue: Boolean True if value is found, False if it isn't or if Error.
	 *		ParseArrayGetKeyList: A list of top-level indexes in an array.
	 * =====================================================================
	 */
	Let ( [
		/**
		 * local vars used by any/all sections
		 */
		private = If ( IsEmpty ( private ) ; 0 ; private + 1 ) ;
		
		/**
		 ******************************************************
		 * STEP 0: SET-UP
		 ******************************************************
		 */
		~! = If ( step < 1 ;
			/* function:next_with_param_no_result */
			If ( $~json.ch ≠ "[" ;
				z_jsonParseSupport1 ( 199 /* Error */ ;
					"Pointer was not at start of an array" ; "" ; "" ; ""
				) ;
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
			)
		) ;
		~! = If ( step < 1
				and $~json.ch ≤ " "
			;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		/* check if array is empty */
		~endFound = If ( step < 1
				and IsEmpty ( $~json.error )
				and $~json.ch = "]"
			;
			True &
				/* function:next_no_result */
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
		) ;
		res = If ( step < 1 ;
			Case (
				functionId = 210 ; /* ParseArrayFindEnd */
				"" ;
				
				functionId = 211 ; /* ParseArrayFindValue */
				/* index values start at 0, so anything lower is invalid */
				If ( req < 0
						or ~endFound
					;
					False
				) ;
				
				functionId = 212 ; /* ParseArrayGetKeyList */
				""
			) ;
			res
		) ;
		/* logging start disabled
		~! = If ( step < 1 ;
			LogWriterMemoryCreateEntry (
				"ParseArray setup"
					& " [functionId:" & functionId & "]"
					& " [uuid:" & uuid & "]"
					& " [req:" & req & "]"
					& " [private:" & private & "]"
					& " [res:" & res & "]"
					& " [step:" & step & "]"
					& " [~endFound:" & ~endFound & "]"
			) 
		) ; disabled logging end */
		step = If ( step < 1 ;
			If (
				not IsEmpty ( $~json.error )
					or ~endFound
					or not IsEmpty ( res )
				;
				2 ;		/* clean-up */
				1		/* main */
			) ;
			step
		) ;
		
		/**
		 ******************************************************
		 * STEP 1: MAIN
		 ******************************************************
		 */
		~key = If ( step = 1 ; private ) ;
		~valueFound = If ( step = 1
				and functionId = 211 /* ParseArrayFindValue */
			;
			~key = req
		) ;
		~! = If ( step = 1
				and IsEmpty ( $~json.error )
				and not ~valueFound
			;
			z_jsonParseSupport1 ( 101 /* ParseValueSkip */ ; "" ; "" ; "" ; "" )
		) ;
		~! = If ( step = 1
				and $~json.ch ≤ " "
			;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		/* check if at end of array */
		~endFound = If ( step = 1
				and IsEmpty ( $~json.error )
				and not ~valueFound
				and $~json.ch = "]"
			;
			True &
				/* function:next_no_result */
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
		) ;
		/* advance pointer to start of next value */
		~! = If ( step = 1
				and IsEmpty ( $~json.error )
				and not ~endFound
				and not ~valueFound
			;
			/* function:next_with_param_no_result */
			If ( $~json.ch ≠ "," ;
				z_jsonParseSupport1 ( 199 /* Error */ ;
					"Expected , instead of " & $~json.ch ; "" ; "" ; ""
				) ;
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
			)
			& If ( $~json.ch ≤ " " ;
				z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
			)
		) ;
		res = If ( step = 1 ;
			Case (
				functionId = 210 ; /* ParseArrayFindEnd */
				"" ;
				
				functionId = 211 ; /* ParseArrayFindValue */
				Case (
					~valueFound ; 	True ;
					~endFound ; 	False
				) ;
				
				functionId = 212 ; /* ParseArrayGetKeyList */
				List ( res ; ~key ) ;
			) ;
			res
		) ;
		/* logging start disabled
		~! = If ( step = 1 ;
			LogWriterMemoryCreateEntry (
				"ParseArray main"
				& " [functionId:" & functionId & "]"
				& " [uuid:" & uuid & "]"
				& " [req:" & req & "]"
				& " [private:" & private & "]"
				& " [res:" & res & "]"
				& " [step:" & step & "]"
				& " [~key:" & ~key & "]"
				& " [~valueFound:" & ~valueFound & "]"
				& " [~endFound:" & ~endFound & "]"
			)
		) ; disabled logging end */
		step = If ( step = 1 ;
			If (
				not IsEmpty ( $~json.error )
					or ~endFound
					or ~valueFound
				;
				2 ;		/* clean-up */
				step	/* recurse */
			) ;
			step
		) ;
		
		/**
		 ******************************************************
		 * ELSE: CLEAN-UP
		 ******************************************************
		 */
		res = If ( step = 2 ;
			If ( not IsEmpty ( $~json.error ) ;
				"Error: " & $~json.error ;
				res
			) ;
			res
		)
		/* logging start disabled
		; ~! = If ( step = 2 ;
			LogWriterMemoryCreateEntry (
				"ParseArray clean-up"
				& " [functionId:" & functionId & "]"
				& " [uuid:" & uuid & "]"
				& " [req:" & req & "]"
				& " [private:" & private & "]"
				& " [res:" & res & "]"
				& " [step:" & step & "]"
				& " [~key:" & ~key & "]"
				& " [~valueFound:" & ~valueFound & "]"
				& " [~endFound:" & ~endFound & "]"
			)
		) disabled logging end */
	] ;
		If ( step = 1 ;
			z_jsonParseSupport2 ( functionId ; req ; private ; res ; step ) ;
			res
		)
	) ;
	
	
	
	functionId = 220 /* ParseObjectFindEnd */
		or functionId = 221 /* ParseObjectFindValue */
		or functionId = 222 /* ParseObjectGetKeyList */
	;
	/**
	 * =====================================================================
	 * OBJECT WALKING FUNCTIONS
	 *
	 * ParseObjectFindEnd: Move pointer to the end of the object.
	 * ParseObjectFindValue: Move pointer to the start of the value for a specified key.
	 * ParseObjectGetKeyList: Get a list of top-level keys in an object.
	 *
	 * parameters:
	 *		req = key to find for ParseObjectFindValue, not used for others
	 *		private = not used
	 *
	 * returns:
	 *		ParseObjectFindEnd: Empty string.
	 *		ParseObjectFindValue: Boolean True if value is found, False if it isn't or if Error.
	 *		ParseObjectGetKeyList: A list of top-level keys in an object.
	 * =====================================================================
	 */
	Let ( [
		/**
		 ******************************************************
		 * STEP 0: SET-UP
		 ******************************************************
		 */
		~! = If ( step < 1 ;
			/* function:next_with_param_no_result */
			If ( $~json.ch ≠ "{" ;
				z_jsonParseSupport1 ( 199 /* Error */ ;
					"Pointer was not at start of an object" ; "" ; "" ; ""
				) ;
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
			)
		) ;
		~! = If ( step < 1
				and $~json.ch ≤ " "
			;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		/* check if object is empty */
		~endFound = If ( step < 1
				and IsEmpty ( $~json.error )
				and $~json.ch = "}"
			;
			True &
				/* function:next_no_result */
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
		) ;
		res = If ( step < 1 ;
			Case (
				functionId = 220 ; /* ParseObjectFindEnd */
				"" ;
				
				functionId = 221 ; /* ParseObjectFindValue */
				If ( IsEmpty ( req )
						or ~endFound
					;
					False
				) ;
				
				functionId = 222 ; /* ParseObjectGetKeyList */
				""
			) ;
			res
		) ;
		/* logging start disabled
		~! = If ( step < 1 ;
			LogWriterMemoryCreateEntry (
				"ParseObject setup"
					& " [functionId:" & functionId & "]"
					& " [uuid:" & uuid & "]"
					& " [req:" & req & "]"
					& " [private:" & private & "]"
					& " [res:" & res & "]"
					& " [step:" & step & "]"
					& " [~endFound:" & ~endFound & "]"
			) 
		) ; disabled logging end */
		step = If ( step < 1 ;
			If (
				not IsEmpty ( $~json.error )
					or ~endFound
					or not IsEmpty ( res )
				;
				2 ;		/* clean-up */
				1		/* main */
			) ;
			step
		) ;
		
		/**
		 ******************************************************
		 * STEP 1: MAIN
		 ******************************************************
		 */
		~key = If ( step = 1 ;
			z_jsonParseSupport3 ( 310 /* ParseString */ ; "" ; "" ; "" ; "" )
		) ;
		~valueFound = If ( step = 1
				and functionId = 221 /* ParseObjectFindValue */
			;
			~key = req
		) ;
		~! = If ( step = 1
				and $~json.ch ≤ " "
			;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		~! = If ( step = 1 ;
			/* function:next_with_param_no_result */
			If ( $~json.ch ≠ ":" ;
				z_jsonParseSupport1 ( 199 /* Error */ ;
					"Expected : instead of " & $~json.ch ; "" ; "" ; ""
				) ;
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
			)
		) ;
		~! = If ( step = 1
				and $~json.ch ≤ " "
			;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		~! = If ( step = 1
				and IsEmpty ( $~json.error )
				and not ~valueFound
			;
			z_jsonParseSupport1 ( 101 /* ParseValueSkip */ ; "" ; "" ; "" ; "" )
		) ;
		~! = If ( step = 1
				and $~json.ch ≤ " "
				and not ~valueFound
			;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		/* check if at end of object */
		~endFound = If ( step = 1
				and IsEmpty ( $~json.error )
				and not ~valueFound
				and $~json.ch = "}"
			;
			True &
				/* function:next_no_result */
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
		) ;
		/* advance pointer to start of next value */
		~! = If ( step = 1
				and IsEmpty ( $~json.error )
				and not ~endFound
				and not ~valueFound
			;
			/* function:next_with_param_no_result */
			If ( $~json.ch ≠ "," ;
				z_jsonParseSupport1 ( 199 /* Error */ ;
					"Expected , instead of " & $~json.ch ; "" ; "" ; ""
				) ;
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
			)
			& If ( $~json.ch ≤ " " ;
				z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
			)
		) ;
		res = If ( step = 1 ;
			Case (
				functionId = 220 ; /* ParseObjectFindEnd */
				"" ;
				
				functionId = 221 ; /* ParseObjectFindValue */
				Case (
					~valueFound ; 	True ;
					~endFound ; 	False
				) ;
				
				functionId = 222 ; /* ParseObjectGetKeyList */
				List ( res ; ~key ) ;
			) ;
			res
		) ;
		/* logging start disabled
		~! = If ( step = 1 ;
			LogWriterMemoryCreateEntry (
				"ParseObject main"
				& " [functionId:" & functionId & "]"
				& " [uuid:" & uuid & "]"
				& " [req:" & req & "]"
				& " [private:" & private & "]"
				& " [res:" & res & "]"
				& " [step:" & step & "]"
				& " [~key:" & ~key & "]"
				& " [~valueFound:" & ~valueFound & "]"
				& " [~endFound:" & ~endFound & "]"
			)
		) ; disabled logging end */
		step = If ( step = 1 ;
			If (
				not IsEmpty ( $~json.error )
					or ~endFound
					or ~valueFound
				;
				2 ;		/* clean-up */
				step	/* recurse */
			) ;
			step
		) ;
		
		/**
		 ******************************************************
		 * ELSE: CLEAN-UP
		 ******************************************************
		 */
		res = If ( step = 2 ;
			If ( not IsEmpty ( $~json.error ) ;
				"Error: " & $~json.error ;
				res
			) ;
			res
		)
		/* logging start disabled
		; ~! = If ( step = 2 ;
			LogWriterMemoryCreateEntry (
				"ParseObject clean-up"
				& " [functionId:" & functionId & "]"
				& " [uuid:" & uuid & "]"
				& " [req:" & req & "]"
				& " [private:" & private & "]"
				& " [res:" & res & "]"
				& " [step:" & step & "]"
				& " [~key:" & ~key & "]"
				& " [~valueFound:" & ~valueFound & "]"
				& " [~endFound:" & ~endFound & "]"
			)
		) disabled logging end */
	] ;
		If ( step = 1 ;
			z_jsonParseSupport2 ( functionId ; req ; private ; res ; step ) ;
			res
		)
	) ;
	
	
	
	/**
	 * =====================================================================
	 * ELSE: FUNCTION NOT FOUND
	 * =====================================================================
	 */
	z_jsonParseSupport1 ( 199 /* Error */ ;
		"FunctionId [" & functionId & "]does not exist" ; "" ; "" ; ""
	)
)

/* logging start disabled
)
disabled logging end */