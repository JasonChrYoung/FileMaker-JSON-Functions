/**
 * =====================================
 * z_jsonParseSupport2 ( functionId ; req ; private ; res ; step )
 *
 * PURPOSE:
 *		Supporting code for native json parsing functions.
 *		mid-level/object walking/array walking
 *
 * PARAMETERS:
 *		functionId = numeric code for function to run, in range of 200 - 299
 *			200		ParseObjectFindEnd
 *			201		ParseObjectFindValue
 *			202		ParseObjectGetKeyList
 *			210		ParseArrayFindEnd
 *			211		ParseArrayFindValue
 *			212		ParseArrayGetKeyList
 *		req = requested data (if any)
 *		private = private data, likely sent to recursive calls of a function
 *		res = response
 *		step = current state of a recursive function
 *
 * DEPENDENCIES:
 *		none
 *
 * HISTORY:
 *		CREATED on 2015-APR-10 by Daniel Smith dansmith65@gmail.com
 *
 * =====================================
 */

/* logging start */
Let ( [
	uuid = Get ( UUID ) ;
	~! = LogWriterMemoryCreateEntry (
		"z_jsonParseSupport2"
			& " [functionId:" & functionId & "]"
			& " [uuid:" & uuid & "]"
			& " [req:" & req & "]"
			& " [private:" & private & "]"
			& " [res:" & res & "]"
			& " [step:" & step & "]"
	)
] ;
/* logging end */
Case (
	
	
	
	functionId = 200 /* ParseObjectFindEnd */
		or functionId = 201 /* ParseObjectFindValue */
		or functionId = 202 /* ParseObjectGetKeyList */
	;
	/**
	 * =====================================================================
	 * OBJECT WALKING FUNCTIONS
	 *
	 * ParseObjectFindEnd: Move pointer to the end of the object.
	 * ParseObjectFindValue: Move pointer to the start of the value for a specified key.
	 * ParseObjectGetKeyList: Get a list of top-level keys in an object.
	 *
	 * parameters:
	 *		req = key to find for ParseObjectFindValue, not used for others
	 *		private = starting position of this object
	 *
	 * returns:
	 *		ParseObjectFindEnd: Empty string.
	 *		ParseObjectFindValue: Cache data if value is found, empty if it isn't.
	 *		ParseObjectGetKeyList: A list of top-level keys in an object.
	 * =====================================================================
	 */
	Let ( [
		~cache.enabled = If ( $json.config.cache.enabled
				and $~json.depth ≤ $json.config.cache.maxdepth
			;
			True
		) ;
		
		/**
		 ******************************************************
		 * STEP 0: SET-UP
		 ******************************************************
		 */
		/* save the starting position of this object */
		~startPos = If ( step < 1 ;
			$~json.at - 1 ;
			private
		) ;
		$~json.depth = If ( step < 1 ;
			$~json.depth + 1 ;
			$~json.depth
		) ;
		
		/* READ CACHE */
		step = If ( step < 1
				and ~cache.enabled
				and not IsEmpty ( $~json.cache[$~json.depth] )
			;
			/* logging start */
			LogWriterMemoryCreateEntry (
				"ParseObject cache: read: start"
					& " [functionId:" & functionId & "]"
					& " [uuid:" & uuid & "]"
					& " [req:" & req & "]"
					& " [private:" & private & "]"
					& " [res:" & res & "]"
					& " [step:" & step & "]"
					& " [$~json.cache[" & $~json.depth & "]:" & $~json.cache[$~json.depth] & "]"
			) & /* logging end */
			Case (
				functionId = 201 /* ParseObjectFindValue */ ;
				Let ( [
					~lastEntry = RightValues ( $~json.cache[$~json.depth] ; 1 ) ;
					~cacheIsComplete = Left ( ~lastEntry ; 6 ) = "|DONE|" ;
					/**
					 * search cache for the key
					 * am surrounding the name with the record and column separator characters so
					 * I'm sure to only find a full name match
					 * this will prevent the name "base" from matching "baseball", for example
					 */
					~cachePosStart = Position (
						¶ & $~json.cache[$~json.depth] ;
						¶ & Substitute ( req ; [Char(13);""] ; [Char(10);""] ; ["|";""] ) & "|" ;
						1 ;
						1
					) ;
/*
					~cachePosStart = If ( ~cachePosStart ;
						~cachePosStart - 2 ;
						~cachePosStart
					) ;
*/
					~cachePosEnd = Position ( $~json.cache[$~json.depth] & ¶ ; ¶ ; ~cachePosStart ; 1 ) ;
					~cache = If ( ~cachePosStart ; Middle (
						$~json.cache[$~json.depth] ;
						~cachePosStart ;
						~cachePosEnd - ~cachePosStart
					) )
					/* logging start */
					; ~! = LogWriterMemoryCreateEntry (
						"ParseObject cache: read: data"
							& " [functionId:" & functionId & "]"
							& " [uuid:" & uuid & "]"
							& " [req:" & req & "]"
							& " [private:" & private & "]"
							& " [res:" & res & "]"
							& " [step:" & step & "]"
							& " [~lastEntry:" & ~lastEntry & "]"
							& " [~cacheIsComplete:" & ~cacheIsComplete & "]"
							& " [~cachePosStart:" & ~cachePosStart & "]"
							& " [~cachePosEnd:" & ~cachePosEnd & "]"
							& " [~cache:" & ~cache & "]"
					) /* logging end */
				] ;
					Case (
						/* key found in cache */
						/* TODO: do I need to update the value of $~json.at and $~json.ch ? */
						~cachePosStart ;
						Let ( [
							/* cache stores position as an offset from the start of the object, undo that offset so the position is based on the offset from the start of the entire json string */
							~! = If ( IsEmpty ( ~cache ) ;
								z_jsonParseSupport1 ( 199 /* Error */ ;
									"Invalid cache:" & Quote ( ~cache ) ; "" ; "" ; ""
								)
							) ;
							~cacheAsList = Substitute ( ~cache ; "|" ; ¶ ) ;
							~keyStartPos = GetValue ( ~cacheAsList ; 2 ) ;
							~valueStartPos = GetValue ( ~cacheAsList ; 4 ) ;
							~valueEndPos = GetValue ( ~cacheAsList ; 5 ) ;
							/* NOTE: do not need to return hash */
							/* NOTE: applying an offset is not necessary unless I add a feature which allows accessing a specific value from a child object */
							~cacheWithOffsetApplied = 
								GetValue ( ~cacheAsList ; 1 )
									& "|" & If ( not IsEmpty ( ~keyStartPos ) ;
										GetAsNumber ( ~keyStartPos ) + ~startPos - 1
									)
									& "|" & GetValue ( ~cacheAsList ; 3 )
									& "|" & GetAsNumber ( ~valueStartPos ) + ~startPos - 1
									& "|" & GetAsNumber ( ~valueEndPos ) + ~startPos - 1
							;
							$res = ~cacheWithOffsetApplied ;
							~nextStep = 2 /* clean-up */
							/* logging start */
							; ~! = LogWriterMemoryCreateEntry (
								"ParseObject cache: read: found"
									& " [functionId:" & functionId & "]"
									& " [uuid:" & uuid & "]"
									& " [req:" & req & "]"
									& " [private:" & private & "]"
									& " [res:" & res & "]"
									& " [step:" & step & "]"
									& " [~nextStep:" & ~nextStep & "]"
									& " [~cacheWithOffsetApplied:" & ~cacheWithOffsetApplied & "]"
							) /* logging end */
						] ;
							~nextStep
						) ;
						
						/* key does not exist */
						~cacheIsComplete ;
						2 ; /* nextStep: clean-up */
						
						/* else: search the object for the value, starting where cache left off */
						/* TODO: there is another potential scenario here: cache[depth] does not exist, but cache.hash does */
						Let ( [
							~length = Length ( ~cache ) ;
							~lastPipe = Position ( ~cache ; "|" ; ~length ; -1 ) ;
							~lastAt = Right ( ~cache ; ~length - ~lastPipe ) ;
							$~json.at = GetAsNumber ( ~lastAt ) + ~startPos ;
							$~json.ch = Middle ( $~json.text ; $~json.at - 1 ; 1 ) ;
							~nextStep = 1 /* main */
							/* logging start */
							; ~! = LogWriterMemoryCreateEntry (
								"ParseObject cache: read: not in cache and cache not complete"
									& " [functionId:" & functionId & "]"
									& " [uuid:" & uuid & "]"
									& " [req:" & req & "]"
									& " [private:" & private & "]"
									& " [res:" & res & "]"
									& " [step:" & step & "]"
									& " [~cache:" & ~cache & "]"
									& " [~nextStep:" & ~nextStep & "]"
							) /* logging end */
						] ;
							If ( IsEmpty ( ~lastAt ) ;
								2 /* nextStep: clean-up */
									& z_jsonParseSupport1 ( 199 /* Error */ ;
										"Invalid 'lastAt' value in cache: " & Quote ( ~cache ) ; "" ; "" ; ""
									)
								;
								~nextStep
							)
						)
					)
				)
			) ;
			/* else */
			step
				/* logging start */
				& LogWriterMemoryCreateEntry (
					"ParseObject cache: read: not found"
						& " [functionId:" & functionId & "]"
						& " [uuid:" & uuid & "]"
						& " [req:" & req & "]"
						& " [private:" & private & "]"
						& " [res:" & res & "]"
						& " [step:" & step & "]"
						& " [$~json.cache[" & $~json.depth & "]:" & $~json.cache[$~json.depth] & "]"
				) /* logging end */
		) ;
		
		/* pass data up from above calculations to a root-level let variable */
		res = If ( ~cache.enabled and not IsEmpty ( $res ) ;
			Let ( [ res = $res ; $res = "" ] ; res ) ;
			res
		) ;
		
		
		~! = If ( step < 1 ;
			/* function:next_with_param_no_result */
			If ( $~json.ch ≠ "{" ;
				z_jsonParseSupport1 ( 199 /* Error */ ;
					"Pointer was not at start of an object" ; "" ; "" ; ""
				) ;
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
			)
		) ;
		~! = If ( step < 1
				and $~json.ch ≤ " "
			;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		/* check if object is empty */
		~endFound = If ( step < 1
				and IsEmpty ( $json.error )
				and $~json.ch = "}"
			;
			True &
				/* function:next_no_result */
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
		) ;
		res = If ( step < 1 ;
			Case (
				functionId = 200 ; /* ParseObjectFindEnd */
				"" ;
				
				functionId = 201 ; /* ParseObjectFindValue */
				If ( IsEmpty ( req )
						or ~endFound
					;
					False
				) ;
				
				functionId = 202 ; /* ParseObjectGetKeyList */
				""
			) ;
			res
		) ;
		/* logging start */
		~! = If ( step < 1 ;
			LogWriterMemoryCreateEntry (
				"ParseObject setup"
					& " [functionId:" & functionId & "]"
					& " [uuid:" & uuid & "]"
					& " [req:" & req & "]"
					& " [private:" & private & "]"
					& " [res:" & res & "]"
					& " [step:" & step & "]"
					& " [~endFound:" & ~endFound & "]"
			) 
		) ; /* logging end */
		step = If ( step < 1 ;
			If (
				not IsEmpty ( $json.error )
					or ~endFound
					or not IsEmpty ( res )
				;
				2 ;		/* clean-up */
				1		/* main */
			) ;
			step
		) ;
		
		/**
		 ******************************************************
		 * STEP 1: MAIN
		 ******************************************************
		 */
		~keyStartPos = If ( step = 1 ;
			$~json.at - 1
		) ;
		~key = If ( step = 1 ;
			z_jsonParseSupport3 ( 310 /* ParseString */ ; "" ; "" ; "" ; "" )
		) ;
		~valueFound = If ( step = 1
				and functionId = 201 /* ParseObjectFindValue */
			;
			~key = req
		) ;
		~! = If ( step = 1
				and $~json.ch ≤ " "
			;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		~! = If ( step = 1 ;
			/* function:next_with_param_no_result */
			If ( $~json.ch ≠ ":" ;
				z_jsonParseSupport1 ( 199 /* Error */ ;
					"Expected : instead of " & $~json.ch ; "" ; "" ; ""
				) ;
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
			)
		) ;
		~! = If ( step = 1
				and $~json.ch ≤ " "
			;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		~valueType = If ( step = 1 ;
			Case (
				$~json.ch = "{" ;	"o" ;
				$~json.ch = "[" ;	"a" ;
				$~json.ch = "\"" ;	"s" ;
				$~json.ch = "-" or ( $~json.ch ≥ 0 and $~json.ch ≤ 9 ) ;		"n" ;
				/* else: assume word */
				"w"
			)
		) ;
		~valStartPos = If ( step = 1 ;
			$~json.at - 1
		) ;
		~value = If ( step = 1 and IsEmpty ( $json.error ) ;
			If ( ~cache.enabled and ( ~valueType = "o" or ~valueType = "a" );
				/* parse and return the value, so it can be hashed, for caching */
				z_jsonParseSupport1 ( 100 /* ParseValue */ ; "" ; "" ; "" ; "" ) ;
				/* else: don't need the value */
				z_jsonParseSupport1 ( 101 /* ParseValueSkip */ ; "" ; "" ; "" ; "" )
			)
		) ;
		~valEndPos = If ( step = 1 ;
			$~json.at - 2
		) ;
		~! = If ( step = 1 and $~json.ch ≤ " " ;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		/* check if at end of object */
		~endFound = If ( step = 1
				and IsEmpty ( $json.error )
				and $~json.ch = "}"
			;
			True &
				/* function:next_no_result */
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
		) ;
		/* advance pointer to start of next value */
		~! = If ( step = 1
				and IsEmpty ( $json.error )
				and not ~endFound
			;
			/* function:next_with_param_no_result */
			If ( $~json.ch ≠ "," ;
				z_jsonParseSupport1 ( 199 /* Error */ ;
					"Expected , instead of " & $~json.ch ; "" ; "" ; ""
				) ;
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
			)
			& If ( $~json.ch ≤ " " ;
				z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
			)
		) ;
		/*
		 * add this value to cache
		 */
		$~json.cache[$~json.depth] = If ( step = 1
				and IsEmpty ( $json.error )
				and ~cache.enabled
			;
			/* logging start */
			LogWriterMemoryCreateEntry (
				"ParseObject main: add value to cache"
				& " [functionId:" & functionId & "]"
				& " [uuid:" & uuid & "]"
				& " [req:" & req & "]"
				& " [private:" & private & "]"
				& " [res:" & res & "]"
				& " [step:" & step & "]"
				& " [$~json.cache[" & $~json.depth & "]:" & $~json.cache[$~json.depth] & "]"
			) & /* logging end */
			List ( $~json.cache[$~json.depth] ;
				Substitute ( ~key ; [Char(13);""] ; [Char(10);""] ; ["|";""] )
					& "|" & ~keyStartPos - ~startPos + 1
					& "|" & ~valueType
					& "|" & ~valStartPos - ~startPos + 1
					& "|" & ~valEndPos - ~startPos + 1
					& "|" & /* hash */ If ( ~valueType = "o" or ~valueType = "a" ;
						GetContainerAttribute ( ~value ; "MD5" )
					)
					& "|" & $~json.at - ~startPos - If ( ~endFound ; 1 )
			) ;
			/* logging start */
			LogWriterMemoryCreateEntry (
				"ParseObject main: value NOT added to cache"
				& " [functionId:" & functionId & "]"
				& " [uuid:" & uuid & "]"
				& " [req:" & req & "]"
				& " [private:" & private & "]"
				& " [res:" & res & "]"
				& " [step:" & step & "]"
				& " [~cache.enabled:" & ~cache.enabled & "]"
				& " [$~json.cache[" & $~json.depth & "]:" & $~json.cache[$~json.depth] & "]"
			) & /* logging end */
			$~json.cache[$~json.depth]
		) ;
		
		res = If ( step = 1 ;
			Case (
				functionId = 200 ; /* ParseObjectFindEnd */
				"" ;
				
				functionId = 201 ; /* ParseObjectFindValue */
				If ( ~valueFound ;
					/* returned data is almost the same as the format used in cache, except the position values are not offset and it does not include hash */
					Substitute ( ~key ; [Char(13);""] ; [Char(10);""] ; ["|";""] )
						& "|" & ~keyStartPos
						& "|" & ~valueType
						& "|" & ~valStartPos
						& "|" & ~valEndPos
				) ;
				
				functionId = 202 ; /* ParseObjectGetKeyList */
				List ( res ; ~key )
			) ;
			res
		) ;
		
		/* logging start */
		~! = If ( step = 1 ;
			LogWriterMemoryCreateEntry (
				"ParseObject main"
				& " [functionId:" & functionId & "]"
				& " [uuid:" & uuid & "]"
				& " [req:" & req & "]"
				& " [private:" & private & "]"
				& " [res:" & res & "]"
				& " [step:" & step & "]"
				& " [~key:" & ~key & "]"
				& " [~valueFound:" & ~valueFound & "]"
				& " [~endFound:" & ~endFound & "]"
				& " [~keyStartPos:" & ~keyStartPos & "]"
				& " [~valueType:" & ~valueType & "]"
				& " [~valStartPos:" & ~valStartPos & "]"
				& " [~valEndPos:" & ~valEndPos & "]"
				& " [$~json.cache[" & $~json.depth & "]:" & $~json.cache[$~json.depth] & "]"
			)
		) ; /* logging end */
		
		step = If ( step = 1 ;
			If (
				not IsEmpty ( $json.error )
					or ~endFound
					or ~valueFound
				;
				2 ;		/* clean-up */
				step	/* recurse */
			) ;
			step
		) ;
		
		/**
		 ******************************************************
		 * ELSE: CLEAN-UP
		 ******************************************************
		 */
		res = If ( step = 2 ;
			If ( not IsEmpty ( $json.error ) ;
				"?" ;
				res
			) ;
			res
		) ;
		/* SAVE CACHE */
		~! = If ( step = 2
				and IsEmpty ( $json.error )
				and ~cache.enabled
				and ~endFound
			;
			Let ( [
				~value = Middle ( $~json.text ; ~startPos ; $~json.at - ~startPos - 1 ) ;
				~hash = GetContainerAttribute ( ~value ; "MD5" ) ;
				/* logging start */
				~! = LogWriterMemoryCreateEntry (
					"ParseObject clean-up"
					& " [functionId:" & functionId & "]"
					& " [value:" & ~value & "]"
					& " [hash:" & ~hash & "]"
				) ; /* logging end */
				$~json.cache.hash = List ( $~json.cache.hash ; ~hash ) ;
				$~json.cache[$~json.depth] = List ( $~json.cache[$~json.depth] ; "|DONE|" ) ;
				~data = Quote ( $~json.cache[$~json.depth] ) ;
				$~json.cache.data = List ( $~json.cache.data ; ~data )
			] ; "" )
		) ;
		/* logging start */
		~! = If ( step = 2 ;
			LogWriterMemoryCreateEntry (
				"ParseObject clean-up"
				& " [functionId:" & functionId & "]"
				& " [uuid:" & uuid & "]"
				& " [req:" & req & "]"
				& " [private:" & private & "]"
				& " [res:" & res & "]"
				& " [step:" & step & "]"
				& " [~key:" & ~key & "]"
				& " [~valueFound:" & ~valueFound & "]"
				& " [~endFound:" & ~endFound & "]"
				& " [~startPos:" & ~startPos & "]"
				& "¶[$~json.cache[" & $~json.depth & "]:" & $~json.cache[$~json.depth] & "]"
				& "¶[$~json.cache.hash:" & $~json.cache.hash & "]"
				& "¶[$~json.cache.data:" & $~json.cache.data & "]"
			)
		) ; /* logging end */
		$~json.depth = If ( step = 2 ;
			$~json.depth - 1 ;
			$~json.depth
		)
	] ;
		If ( step = 1 ;
			z_jsonParseSupport2 ( functionId ; req ; ~startPos ; res ; step ) ;
			res
		)
	) ;
	
	
	
	functionId = 210 /* ParseArrayFindEnd */
		or functionId = 211 /* ParseArrayFindValue */
		or functionId = 212 /* ParseArrayGetKeyList */
	;
	/**
	 * =====================================================================
	 * ARRAY WALKING FUNCTIONS
	 *
	 * ParseArrayFindEnd: Move pointer to the end of the array.
	 * ParseArrayFindValue: Move pointer to the start of the value for a specified index.
	 * ParseArrayGetKeyList: Get a list of top-level indexes in an array.
	 *
	 * parameters:
	 *		req = index to find for ParseArrayFindValue, not used for others
	 *		private = current array index
	 *
	 * returns:
	 *		ParseArrayFindEnd: Empty string.
	 *		ParseArrayFindValue: Boolean True if value is found, False if it isn't or if Error.
	 *		ParseArrayGetKeyList: A list of top-level indexes in an array.
	 * =====================================================================
	 */
	Let ( [
		/**
		 * local vars used by any/all sections
		 */
		private = If ( IsEmpty ( private ) ; 0 ; private + 1 ) ;
		
		/**
		 ******************************************************
		 * STEP 0: SET-UP
		 ******************************************************
		 */
		~! = If ( step < 1 ;
			/* function:next_with_param_no_result */
			If ( $~json.ch ≠ "[" ;
				z_jsonParseSupport1 ( 199 /* Error */ ;
					"Pointer was not at start of an array" ; "" ; "" ; ""
				) ;
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
			)
		) ;
		~! = If ( step < 1
				and $~json.ch ≤ " "
			;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		/* check if array is empty */
		~endFound = If ( step < 1
				and IsEmpty ( $json.error )
				and $~json.ch = "]"
			;
			True &
				/* function:next_no_result */
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
		) ;
		res = If ( step < 1 ;
			Case (
				functionId = 210 ; /* ParseArrayFindEnd */
				"" ;
				
				functionId = 211 ; /* ParseArrayFindValue */
				/* index values start at 0, so anything lower is invalid */
				If ( req < 0
						or ~endFound
					;
					False
				) ;
				
				functionId = 212 ; /* ParseArrayGetKeyList */
				""
			) ;
			res
		) ;
		/* logging start */
		~! = If ( step < 1 ;
			LogWriterMemoryCreateEntry (
				"ParseArray setup"
					& " [functionId:" & functionId & "]"
					& " [uuid:" & uuid & "]"
					& " [req:" & req & "]"
					& " [private:" & private & "]"
					& " [res:" & res & "]"
					& " [step:" & step & "]"
					& " [~endFound:" & ~endFound & "]"
			) 
		) ; /* logging end */
		step = If ( step < 1 ;
			If (
				not IsEmpty ( $json.error )
					or ~endFound
					or not IsEmpty ( res )
				;
				2 ;		/* clean-up */
				1		/* main */
			) ;
			step
		) ;
		
		/**
		 ******************************************************
		 * STEP 1: MAIN
		 ******************************************************
		 */
		~key = If ( step = 1 ; private ) ;
		~valueFound = If ( step = 1
				and functionId = 211 /* ParseArrayFindValue */
			;
			~key = req
		) ;
		~valStartPos = If ( step = 1 ;
			$~json.at - 1
		) ;
		~! = If ( step = 1
				and IsEmpty ( $json.error )
			;
			z_jsonParseSupport1 ( 101 /* ParseValueSkip */ ; "" ; "" ; "" ; "" )
		) ;
		~valEndPos = If ( step = 1 ;
			$~json.at - 2
		) ;
		~! = If ( step = 1
				and $~json.ch ≤ " "
			;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		/* check if at end of array */
		~endFound = If ( step = 1
				and IsEmpty ( $json.error )
				and $~json.ch = "]"
			;
			True &
				/* function:next_no_result */
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
		) ;
		/* advance pointer to start of next value */
		~! = If ( step = 1
				and IsEmpty ( $json.error )
				and not ~endFound
			;
			/* function:next_with_param_no_result */
			If ( $~json.ch ≠ "," ;
				z_jsonParseSupport1 ( 199 /* Error */ ;
					"Expected , instead of " & $~json.ch ; "" ; "" ; ""
				) ;
				Let ( [
					$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
					$~json.at = $~json.at + 1
				] ;
					""
				)
			)
			& If ( $~json.ch ≤ " " ;
				z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
			)
		) ;
		~cache = If ( step = 1 ;
			~key
				& "|" /* TODO: add value type abbreviation: a, o, s, n, w */
				& "|" /* array does not have a key start position */
				& "|" & ~valStartPos
				& "|" & ~valEndPos
				& "|" /* TODO: hash if value is an object or array */
		) ;
		res = If ( step = 1 ;
			Case (
				functionId = 210 ; /* ParseArrayFindEnd */
				"" ;
				
				functionId = 211 ; /* ParseArrayFindValue */
				If (
					~valueFound ;
					~cache
				) ;
				
				functionId = 212 ; /* ParseArrayGetKeyList */
				List ( res ; ~key ) ;
			) ;
			res
		) ;
		/* logging start */
		~! = If ( step = 1 ;
			LogWriterMemoryCreateEntry (
				"ParseArray main"
				& " [functionId:" & functionId & "]"
				& " [uuid:" & uuid & "]"
				& " [req:" & req & "]"
				& " [private:" & private & "]"
				& " [res:" & res & "]"
				& " [step:" & step & "]"
				& " [~key:" & ~key & "]"
				& " [~valueFound:" & ~valueFound & "]"
				& " [~endFound:" & ~endFound & "]"
			)
		) ; /* logging end */
		step = If ( step = 1 ;
			If (
				not IsEmpty ( $json.error )
					or ~endFound
					or ~valueFound
				;
				2 ;		/* clean-up */
				step	/* recurse */
			) ;
			step
		) ;
		
		/**
		 ******************************************************
		 * ELSE: CLEAN-UP
		 ******************************************************
		 */
		res = If ( step = 2 ;
			If ( not IsEmpty ( $json.error ) ;
				"?" ;
				res
			) ;
			res
		)
		/* logging start */
		; ~! = If ( step = 2 ;
			LogWriterMemoryCreateEntry (
				"ParseArray clean-up"
				& " [functionId:" & functionId & "]"
				& " [uuid:" & uuid & "]"
				& " [req:" & req & "]"
				& " [private:" & private & "]"
				& " [res:" & res & "]"
				& " [step:" & step & "]"
				& " [~key:" & ~key & "]"
				& " [~valueFound:" & ~valueFound & "]"
				& " [~endFound:" & ~endFound & "]"
			)
		) /* logging end */
	] ;
		If ( step = 1 ;
			z_jsonParseSupport2 ( functionId ; req ; private ; res ; step ) ;
			res
		)
	) ;
	
	
	
	/**
	 * =====================================================================
	 * ELSE: FUNCTION NOT FOUND
	 * =====================================================================
	 */
	z_jsonParseSupport1 ( 199 /* Error */ ;
		"FunctionId [" & functionId & "]does not exist" ; "" ; "" ; ""
	)
)

/* logging start */
)
/* logging end */