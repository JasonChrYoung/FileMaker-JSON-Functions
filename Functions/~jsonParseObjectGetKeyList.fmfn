/**
 * =====================================
 * ~jsonParseObjectGetKeyList ( step )
 *
 * RETURNS:
 *		A list of top-level keys in an object.
 *
 * PARAMETERS:
 *		step = always leave empty when calling this function
 *			(stores the current state of processing this recursive function is in)
 *
 * DEPENDENCIES:
 *		Pointer is expected to be at { starting the object.
 *		Custom Functions:
 *			~jsonParseObjectGetKeyList		(self: it's recursive!)
 *			~jsonParseError
 *			~jsonParseNext
 *			~jsonParseWhitespace
 *			~jsonParseString
 *			~jsonParseValueSkip
 *
 * NOTES:
 *
 * HISTORY:
 *		CREATED on 2015-APR-04 by Daniel Smith dansmith65@gmail.com
 *
 * =====================================
 */

Case (
	/**
	 ***************************************************************************
	 * STEP 0: SET-UP
	 ***************************************************************************
	 */
	not step ;
	Let ( [
		~! = /* logging start */ LogWriterMemoryCreateEntry (
			"~jsonParseObjectGetKeyList [step:0]"
		) & /* logging end */ "" ;
		
		/* initialize variable */
		$~jsonParseObjectGetKeyList.result = "" ;
		
		~! = If ( IsEmpty ( ~jsonParseNext ( "{" ) ) ;
			~jsonParseError ( "Pointer was not at start of an object" )
		) ;
		
		~! = If ( IsEmpty ( $~json.error ) ;
			~jsonParseWhitespace
		) ;
		
		/* check if object is empty */
		~endFound = If ( IsEmpty ( $~json.error ) ;
			If ( $~json.ch = "}" ;
				True
					& ~jsonDiscardResult ( ~jsonParseNext ( "}" ) )
			)
		) ;
		
		~nextStep = If (
			not IsEmpty ( $~json.error )
				or ~endFound
			;
			2 ;	/* clean-up */
			1	/* main */
		)
	] ;
		~jsonParseObjectGetKeyList ( ~nextStep )
	) ;
	
	
	/**
	 ***************************************************************************
	 * STEP 1: MAIN
	 ***************************************************************************
	 */
	step = 1 ;
	Let ( [
		~! = /* logging start */ LogWriterMemoryCreateEntry (
			"~jsonParseObjectGetKeyList [step:1]"
		) & /* logging end */ "" ;
		
		~key = ~jsonParseString ;
		
		$~jsonParseObjectGetKeyList.result = If ( IsEmpty ( $~json.error ) ;
			List (
				$~jsonParseObjectGetKeyList.result ;
				~key
			)
		) ;
		
		~! = If ( IsEmpty ( $~json.error ) ;
			~jsonParseWhitespace
		) ;
		
		~! = If ( IsEmpty ( $~json.error ) ;
			~jsonParseNext ( ":" )
		) ;
		
		~! = If ( IsEmpty ( $~json.error ) ;
			~jsonParseWhitespace
		) ;
		
		~! = If ( IsEmpty ( $~json.error ) ;
			~jsonParseValueSkip
		) ;
		
		~! = If ( IsEmpty ( $~json.error ) ;
			~jsonParseWhitespace
		) ;
		
		/* check if at end of object */
		~endFound = If ( IsEmpty ( $~json.error ) ;
			If ( $~json.ch = "}" ;
				True
					& ~jsonDiscardResult ( ~jsonParseNext ( "}" ) )
			)
		) ;
		
		/* advance pointer to start of next key */
		~! = If ( IsEmpty ( $~json.error ) and not ~endFound ;
			~jsonParseNext ( "," )
			& If ( IsEmpty ( $~json.error ) ;
				~jsonParseWhitespace
			)
		) ;
		
		~nextStep = If (
			not IsEmpty ( $~json.error )
				or ~endFound
			;
			2 ;	/* clean-up */
			1	/* main */
		)
	] ;
		~jsonParseObjectGetKeyList ( ~nextStep )
	) ;
	
	
	/**
	 ***************************************************************************
	 * STEP 2: CLEAN-UP
	 ***************************************************************************
	 */
	step = 2 ;
	Let ( [
		~result = If ( IsEmpty ( $~json.error ) ;
			$~jsonParseObjectGetKeyList.result ;
			"Error: " & $~json.error
		) ;
		
		~! = /* logging start */ LogWriterMemoryCreateEntry (
			"~jsonParseObjectGetKeyList [step:2]"
				& " [result:" & ~result & "]"
		) & /* logging end */ "" ;
		
		/* clean up local variables */
		$~jsonParseObjectGetKeyList.result = ""
	] ;
		~result
	)
)