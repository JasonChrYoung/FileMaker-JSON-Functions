/**
 * =====================================
 * ~jsonParseObjectFindValue ( key )
 *
 * PURPOSE:
 *		Move pointer to the start of the value for a specified key.
 *
 * RETURNS:
 *		Boolean True if value is found, False if it isn't or if Error.
 *
 * PARAMETERS:
 *		key = object property/name
 *
 * DEPENDENCIES:
 *		The pointer is expected to be on the "{" in the object.
 *
 * HISTORY:
 *		CREATED on 2015-MAR-31 by Daniel Smith dansmith65@gmail.com
 *
 * =====================================
 */

Case (
	/* Step 0, set-up */
	not $~jsonParseObjectFindValue.step ;
	Let ( [
		~! = /* logging start disabled LogWriterMemoryCreateEntry (
			"~jsonParseObjectFindValue [step:0]"
				& " [i:" & $~jsonParseObjectFindValue.i & "]"
		) & disabled logging end */ "" ;

		~result = If ( IsEmpty ( ~jsonParseNext ( "{" ) ) ;
			"Error: " & $~json.error  /* TODO: this message does not need to be set here */
		) & ~jsonParseWhitespace ;
		
		/* check if object is empty */
		~result = Case (
			Not IsEmpty ( ~result ) ;
			~result ;
			
			$~json.ch = "}" ;
			False & ~jsonDiscardResult ( ~jsonParseNext ( "}" ) ) 
		) ;
		
		$~jsonParseObjectFindValue.result = ~result ;
		$~jsonParseObjectFindValue.step = If (
			Not IsEmpty ( $~json.error )
				or Not IsEmpty ( $~jsonParseObjectFindValue.result )
			;
			2 ;
			1
		)
	] ;
		~jsonParseObjectFindValue ( key )
	) ;

	
	/* Step 1, main */
	$~jsonParseObjectFindValue.step = 1 ;
	Let ( [
		~! = /* logging start disabled LogWriterMemoryCreateEntry (
			"~jsonParseObjectFindValue [step:1]"
				& " [i:" & $~jsonParseObjectFindValue.i & "]"
		) & disabled logging end */ "" ;

		~result = If (
			~jsonParseString = key ;
			/* found the value it was looking for! */
			True
		) ;
		/* as long as there was no error, advance pointer to start of value */
		~! = If ( IsEmpty ( $~json.error ) ;
			~jsonParseWhitespace
			& ~jsonParseNext ( ":" )
			& ~jsonParseWhitespace
		) ;
		/* if there was no error, and key did not match, advance pointer to next key */
		~! = If ( IsEmpty ( $~json.error ) and IsEmpty ( ~result ) ;
			~jsonParseValueSkip
			& ~jsonParseWhitespace
		) ;
		/* check if at end of object */
		~result = Case (
			Not IsEmpty ( ~result ) ;
			~result ;
			
			$~json.ch = "}" ;
			False & ~jsonDiscardResult ( ~jsonParseNext ( "}" ) ) 
		) ;

		/* if there was no error, and key did not match, and not at end of object, advance pointer to next key */
		~! = If ( IsEmpty ( $~json.error ) and IsEmpty ( ~result ) ;
			~jsonParseNext ( "," )
			& ~jsonParseWhitespace
		) ;
		
		$~jsonParseObjectFindValue.i = $~jsonParseObjectFindValue.i + 1 ;
		$~jsonParseObjectFindValue.result = ~result ;
		$~jsonParseObjectFindValue.step = If (
			Not IsEmpty ( $~json.error )
				or Not IsEmpty ( $~jsonParseObjectFindValue.result )
			;
			2 ;
			1
		)
	] ;
		~jsonParseObjectFindValue ( key )
	) ;

	
	/* Step 2, clean-up and return result */
	$~jsonParseObjectFindValue.step = 2 ;
	Let ( [
		~! = /* logging start disabled LogWriterMemoryCreateEntry (
			"~jsonParseObjectFindValue [step:2]"
				& " [i:" & $~jsonParseObjectFindValue.i & "]"
				& " [result:" & $~jsonParseObjectFindValue.result & "]"
		) & disabled logging end */ "" ;

		~result = If ( IsEmpty ( $~json.error ) ;
			$~jsonParseObjectFindValue.result ;
			False
		) ;
		// purge variables
		$~jsonParseObjectFindValue.i = "" ;
		$~jsonParseObjectFindValue.step = "" ;
		$~jsonParseObjectFindValue.result = ""
	] ;
		~result
	)
)