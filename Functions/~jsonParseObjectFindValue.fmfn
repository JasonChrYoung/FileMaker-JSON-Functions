/**
 * =====================================
 * ~jsonParseObjectFindValue ( key )
 *
 * PURPOSE:
 *		Move pointer to the start of the value for a specified key.
 *
 * RETURNS:
 *		Boolean True if value is found, False if it isn't
 *		"json:error" if an error occurred
 *
 * PARAMETERS:
 *		key = object property/name
 *
 * DEPENDENCIES:
 *		The pointer is expected to be on the "{" in the object.
 *
 * HISTORY:
 *		CREATED on 2015-MAR-31 by Daniel Smith dansmith65@gmail.com
 *
 * =====================================
 */

/* logging start */ LogWriterMemoryCreateEntry (
	"~jsonParseObjectFindValue start [step:" & $~jsonParseObjectFindValue.step & "]"
) & /* logging end */

Case (
	/* Step 0, set-up */
	not $~jsonParseObjectFindValue.step ;
	Let ( [
		~result = If ( IsEmpty ( ~jsonParseNext ( "{" ) ) ;
			"json:error"
		) & ~jsonParseWhitespace ;
		
		/* check if object is empty */
		~result = Case (
			Not IsEmpty ( ~result ) ;
			~result ;
			
			$~json.ch = "}" ;
			False & ~jsonDiscardResult ( ~jsonParseNext ( "}" ) ) 
		) ;
		
		$~jsonParseObjectFindValue.result = ~result ;
		$~jsonParseObjectFindValue.step = If (
			Not IsEmpty ( $~jsonParseObjectFindValue.result ) ;
			2 ;
			1
		)
	] ;
		~jsonParseObjectFindValue ( key )
	) ;

	
	/* Step 1, main */
	$~jsonParseObjectFindValue.step = 1 ;
	Let ( [
		~result = If (
			~jsonParseString = key ;
			/* found the value it was looking for! */
			True
		) ;
		/* as long as there was no error, advance pointer to start of value */
		~! = If ( IsEmpty ( $~json.error ) ;
			~jsonParseWhitespace
			& ~jsonParseNext ( ":" )
			& ~jsonParseWhitespace
		) ;
		/* if there was no error, and key did not match, advance pointer to next key */
		~! = If ( IsEmpty ( $~json.error ) and IsEmpty ( ~result ) ;
			~jsonParseValueSkip
			& ~jsonParseWhitespace
		) ;
		/* check if at end of object */
		~result = Case (
			Not IsEmpty ( ~result ) ;
			~result ;
			
			$~json.ch = "}" ;
			False & ~jsonDiscardResult ( ~jsonParseNext ( "}" ) ) 
		) ;

		/* if there was no error, and key did not match, and not at end of object, advance pointer to next key */
		~! = If ( IsEmpty ( $~json.error ) and IsEmpty ( ~result ) ;
			~jsonParseNext ( "," )
			& ~jsonParseWhitespace
		) ;
		
		$~jsonParseObjectFindValue.i = $~jsonParseObjectFindValue.i + 1 ;
		$~jsonParseObjectFindValue.result = ~result ;
		$~jsonParseObjectFindValue.step = If (
			Not IsEmpty ( $~jsonParseObjectFindValue.result ) ;
			2 ;
			1
		)
	] ;
		~jsonParseObjectFindValue ( key )
	) ;

	
	/* Step 2, clean-up and return result */
	$~jsonParseObjectFindValue.step = 2 ;
	Let ( [
		!~ = /* logging start */ LogWriterMemoryCreateEntry (
			"~jsonParseObjectFindValue end [i:" & $~jsonParseObjectFindValue.i & "]"
		) & /* logging end */ "" ;

		~result = $~jsonParseObjectFindValue.result ;
		// purge variables
		$~jsonParseObjectFindValue.i = "" ;
		$~jsonParseObjectFindValue.step = "" ;
		$~jsonParseObjectFindValue.result = ""
	] ;
		~result
	)
)