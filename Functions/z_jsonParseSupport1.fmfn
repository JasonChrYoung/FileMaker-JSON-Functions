/**
 * =====================================
 * z_jsonParseSupport1 ( functionId ; req ; private ; res ; step )
 *
 * PURPOSE:
 *		Supporting code for native json parsing functions.
 *		high-level/supporting/control/dispatch
 *
 * PARAMETERS:
 *		functionId = numeric code for function to run, in range of 100 - 199
 *			100		ParseValue
 *			101		ParseValueSkip
 *					FindValue
 *					FindEnd
 *					IsEmpty
 *			199		Error
 *		req = requested data (if any)
 *		private = private data, likely sent to recursive calls of a function
 *		res = response
 *		step = current state of a recursive function
 *
 * DEPENDENCIES:
 *		none
 *
 * HISTORY:
 *		CREATED on 2015-APR-10 by Daniel Smith dansmith65@gmail.com
 *
 * =====================================
 */

/* logging start disabled
Let ( [
	~! = LogWriterMemoryCreateEntry (
		"z_jsonParseSupport1 "
			& " [functionId:" & functionId & "]"
			& " [step:" & step & "]"
			& " [req:" & req & "]"
			& " [private:" & private & "]"
			& " [res:" & res & "]"
	)
] ;
disabled logging end */
Case (
	
	
	functionId = 100 or functionId = 101 ;
	/**
	 * =====================================================================
	 * ParseValue / ParseValueSkip
	 * 
	 * ParseValue: Extract the value at the current pointer's position.
	 * ParseValueSkip: Find the end of a value.
	 *
	 * parameters:
	 *		req = not used
	 *		private = not used
	 *
	 * returns:
	 *		ParseValue: The extracted value. If the value is an object or array, return the raw json.
	 *		ParseValueSkip: empty string
	 * =====================================================================
	 */
	Let ( [
		~! = ~jsonParseWhitespace ;
		res = Case (
			/* OBJECT */
			$~json.ch = "{" ;
			Let ( [
				~start = $~json.at - 1 ;
				~! = z_jsonParseSupport2 ( 220 /* ParseObjectFindEnd */ ; "" ; "" ; "" ; "" ) ;
				~end =  $~json.at
			] ;
				If ( IsEmpty ( $~json.error ) ;
					Middle (
						$~json.text ;
						~start ;
						~end - ~start - 1
					) ;
					"Error: " & $~json.error
				)
			) ;
			
			/* ARRAY */
			$~json.ch = "[" ;
			Let ( [
				~start = $~json.at - 1 ;
				~! = ~jsonParseArrayFindEnd ( "" ) ;
				~end =  $~json.at
			] ;
				If ( IsEmpty ( $~json.error ) ;
					Middle (
						$~json.text ;
						~start ;
						~end - ~start - 1
					) ;
					"Error: " & $~json.error
				)
			) ;
			
			$~json.ch = "\"" ;
			z_jsonParseSupport3 ( 310 /* ParseString */ ; "" ; "" ; "" ; "" ) ;
			
			$~json.ch = "-"
				or (
					$~json.ch ≥ 0
					and $~json.ch ≤ 9
				)
			;
			z_jsonParseSupport3 ( 320 /* ParseNumber */ ; "" ; "" ; "" ; "" ) ;
			
			/* else */
			z_jsonParseSupport3 ( 330 /* ParseWord */ ; "" ; "" ; "" ; "" )
		)
	] ;
		res
	) ;
	
	
	
	functionId = 199 ;
	/**
	 * =====================================================================
	 * Error
	 *
	 * parameters:
	 *		req = error message
	 * =====================================================================
	 */
	Let ( [
		/* *
		 * am not using a standard logging start/end comment because error
		 * logging should always be enabled
		 */
		message = req ;
		~! = LogWriterMemoryCreateEntry (
			"jsonParseError"
				& " [message:" & message & "]"
		) ;
		/* save the error */
		$~json.error = List (
			message
				& If ( $~json.at > 0 ;
					" [ch:" & $~json.ch & "]"
					& " [at:" & $~json.at & "]"
					& " [context:"
						& Middle ( $~json.text ; $~json.at - 11 ; 20 )
						& "]"
				)
			;
			$~json.error
		) ;
		/* trigger parent functions to abort */
		$~json.ch = "" ;
		$~json.at = -1
	] ;
		/**
		 * Don't return anything because calling function can always access
		 * the error from $~json.error, and many calling functions don't
		 * need to access the error.
		 */
		""
	) ;
	
	
	/**
	 * =====================================================================
	 * ELSE: FUNCTION NOT FOUND
	 * =====================================================================
	 */
	z_jsonParseSupport1 ( 199 /* Error */ ;
		"FunctionId [" & functionId & "]does not exist" ; "" ; "" ; ""
	)
)

/* logging start disabled
)
disabled logging end */