/**
 * =====================================
 * z_jsonParseSupport1 ( functionId ; req ; private ; res ; step )
 *
 * PURPOSE:
 *		Supporting code for native json parsing functions.
 *		high-level/supporting/control/dispatch
 *
 * PARAMETERS:
 *		functionId = numeric code for function to run, in range of 100 - 199
 *			100		ParseValue
 *			101		ParseValueSkip
 *			110		GetValuePosition
 *			120		GetEndPosition
 *			121		IsEmpty
 *			199		Error
 *		req = requested data (if any)
 *		private = private data, likely sent to recursive calls of a function
 *		res = response
 *		step = current state of a recursive function
 *
 * DEPENDENCIES:
 *		none
 *
 * HISTORY:
 *		CREATED on 2015-APR-10 by Daniel Smith dansmith65@gmail.com
 *
 * =====================================
 */

/* logging start disabled
Let ( [
	uuid = Get ( UUID ) ;
	~! = LogWriterMemoryCreateEntry (
		"z_jsonParseSupport1 "
			& " [functionId:" & functionId & "]"
			& " [uuid:" & uuid & "]"
			& " [req:" & req & "]"
			& " [private:" & private & "]"
			& " [res:" & res & "]"
			& " [step:" & step & "]"
	)
] ;
disabled logging end */
Case (
	
	
	functionId = 100 or functionId = 101 ;
	/**
	 * =====================================================================
	 * ParseValue / ParseValueSkip
	 * 
	 * ParseValue: Extract the value at the current pointer's position.
	 * ParseValueSkip: Find the end of a value.
	 *
	 * parameters:
	 *		req = not used
	 *		private = not used
	 *
	 * returns:
	 *		ParseValue: The extracted value. If the value is an object or array, return the raw json.
	 *		ParseValueSkip: empty string
	 * =====================================================================
	 */
	Let ( [
		~! = If ( $~json.ch ≤ " " ;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		res = Case (
			/* OBJECT */
			$~json.ch = "{" ;
			Let ( [
				~start = $~json.at - 1 ;
				~! = z_jsonParseSupport2 ( 220 /* ParseObjectFindEnd */ ; "" ; "" ; "" ; "" ) ;
				~end =  $~json.at
			] ;
				If ( IsEmpty ( $json.error ) ;
					Middle (
						$~json.text ;
						~start ;
						~end - ~start - 1
					) ;
					"?"
				)
			) ;
			
			/* ARRAY */
			$~json.ch = "[" ;
			Let ( [
				~start = $~json.at - 1 ;
				~! = z_jsonParseSupport2 ( 210 /* ParseArrayFindEnd */ ; "" ; "" ; "" ; "" ) ;
				~end =  $~json.at
			] ;
				If ( IsEmpty ( $json.error ) ;
					Middle (
						$~json.text ;
						~start ;
						~end - ~start - 1
					) ;
					"?"
				)
			) ;
			
			$~json.ch = "\"" ;
			z_jsonParseSupport3 ( 310 /* ParseString */ ; "" ; "" ; "" ; "" ) ;
			
			$~json.ch = "-"
				or (
					$~json.ch ≥ 0
					and $~json.ch ≤ 9
				)
			;
			z_jsonParseSupport3 ( 320 /* ParseNumber */ ; "" ; "" ; "" ; "" ) ;
			
			/* else */
			z_jsonParseSupport3 ( 330 /* ParseWord */ ; "" ; "" ; "" ; "" )
		)
	] ;
		res
	) ;
	
	
	
	functionId = 110 ;
	/**
	 * =====================================================================
	 * GetValuePosition
	 * 
	 * Find the starting position of a value.
	 *
	 * parameters:
	 *		req = json
	 *		private = keyOrIndex
	 *
	 * returns:
	 *		ParseValue: The extracted value. If the value is an object or array, return the raw json.
	 *		ParseValueSkip: empty string
	 * =====================================================================
	 */
	Let ( [
		/* initialize parsing variables */
		$~json.text = req ;
		$~json.ch = Left ( $~json.text ; 1 ) ;
		$~json.at = 2 ;
		$json.error = "" ;
		~! = If ( $~json.ch ≤ " " ;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		)
	] ;
		Case (
			/* object */
			$~json.ch = "{" ;
			z_jsonParseSupport2 ( 221 /* ParseObjectFindValue */ ; private ; "" ; "" ; "" ) ;
			
			/* array */
			$~json.ch = "[" ;
			z_jsonParseSupport2 ( 211 /* ParseArrayFindValue */ ; private ; "" ; "" ; "" ) ;
			
			/* else: string, number, or word */
			False
				& z_jsonParseSupport1 ( 199 /* Error */ ;
					"value sent to GetValuePosition function was not an object or array" ; "" ; "" ; ""
				)
		)
		
		/* clean-up parsing variables */
		& Let ( [
			$~json.text = "" ;
			$~json.ch = "" ;
			$~json.at = ""
		] ;
			""
		)
	) ;
	
	
	
	functionId = 120 ;
	/**
	 * =====================================================================
	 * GetEndPosition
	 * 
	 * returns:
	 * 		Position of last non-whitespace character in the json.
	 *
	 * parameters:
	 *		req = json
	 *		private = current character
	 *		res = current position
	 *
	 * notes:
	 * 		Accesses the json from a reserved variable, but could potentially
	 *		be modified to access it from the req parameter.
	 * =====================================================================
	 */
	Let ( [
		/* initialize parsing variables on first iteration */
		~ch = If ( not step ;
			" " ;
			private
		) ;
		~at = If ( not step ;
			Length ( req ) ;
			res
		) ;
		
		~ch = Middle ( req ; ~at ; 1 ) ;
		~at = ~at - 1 ;
		~endFound =
			~ch = "}"
			or ~ch = "]"
	] ;
		If ( ~endFound ;
			~at + 1 ;
			z_jsonParseSupport1 ( 120 /* GetEndPosition */ ; req ; ~ch ; ~at ; 1 )
		)
	) ;
	
	
	
	functionId = 121 ;
	/**
	 * =====================================================================
	 * IsEmpty
	 * 
	 * Determine if the json is empty: {} or [] (potentially with whitespace)
	 *
	 * parameters:
	 *		req = json
	 *		private = not used
	 *
	 * returns:
	 *		Boolean True if json is an empty object or array, False if it isn't.
	 * =====================================================================
	 */
	Let ( [
		/* initialize parsing variables */
		$~json.text = req ;
		$~json.ch = Left ( $~json.text ; 1 ) ;
		$~json.at = 2 ;
		
		~! = If ( $~json.ch ≤ " " ;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		
		~! = If ( $~json.ch ≠ "{" and $~json.ch ≠ "[" ;
			z_jsonParseSupport1 ( 199 /* Error */ ;
				"json was not an object or array as expected. Occurred in IsEmpty function." ; "" ; "" ; ""
			)
		) ;
		
		/* function:next_no_result */
		$~json.ch = Middle ( $~json.text ; $~json.at ; 1 ) ;
		$~json.at = $~json.at + 1 ;
		
		~! = If ( $~json.ch ≤ " " ;
			z_jsonParseSupport3 ( 300 /* ParseWhitespace */ ; "" ; "" ; "" ; "" )
		) ;
		
		~ch = $~json.ch ;
		
		/* clean-up parsing variables */
		$~json.text = "" ;
		$~json.ch = "" ;
		$~json.at = ""
	] ;
		If ( IsEmpty ( $json.error ) ;
			~ch = "}" or ~ch = "]"
		)
	) ;
	
	
	
	functionId = 199 ;
	/**
	 * =====================================================================
	 * Error
	 *
	 * parameters:
	 *		req = error message
	 * =====================================================================
	 */
	Let ( [
		/* *
		 * am not using a standard logging start/end comment because error
		 * logging should always be enabled
		 */
		message = req ;
		~! = LogWriterMemoryCreateEntry (
			"Error"
				& " [message:" & message & "]"
		) ;
		/* save the error */
		$json.error = List (
			message
				& If ( $~json.at > 0 ;
					" [ch:" & $~json.ch & "]"
					& " [at:" & $~json.at & "]"
					& " [context:"
						& Middle ( $~json.text ; $~json.at - 11 ; 20 )
						& "]"
				)
			;
			$json.error
		) ;
		/* trigger parent functions to abort */
		$~json.ch = "" ;
		$~json.at = -1
	] ;
		/**
		 * Don't return anything because calling function can always access
		 * the error from $json.error, and many calling functions don't
		 * need to access the error.
		 */
		""
	) ;
	
	
	/**
	 * =====================================================================
	 * ELSE: FUNCTION NOT FOUND
	 * =====================================================================
	 */
	z_jsonParseSupport1 ( 199 /* Error */ ;
		"FunctionId [" & functionId & "]does not exist" ; "" ; "" ; ""
	)
)

/* logging start disabled
)
disabled logging end */