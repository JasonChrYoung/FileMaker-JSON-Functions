/**
 * =====================================
 * jsonModify ( json ; keyOrIndex ; newValue )
 *
 * PURPOSE:
 *		Add or modify an object by it's key, or array by it's index.
 *
 * RETURNS:
 *		The modified JSON.
 *
 * PARAMETERS:
 *		json = the json string
 *		keyOrIndex = object property key (name) or array index (position)
 *		newValue = string, number, or a named constant:
 *			json:true, json:false, json:null
 *			should NOT be an object or array (these will be encoded as strings)
 *
 * DEPENDENCIES:
 *		Custom Functions:
 *			~jsonFindValue
 *			~jsonEncodeValue
 *
 * NOTES:
 *
 * TODO:
 *		Determine how to add an array value
 *			- should it allow positional insertion?
 *				- insert before other values
 *					- negative number?
 *					- "unshift" (like the json method) ?
 *				- insert between values
 *					- decimal: 2.5 would insert after 2?
 *				- insert at end
 *					- I assume this would be the most common use-case
 *					- empty keyOrIndex value?
 *			- if the index is higher than array size + 1, should it pad the array
 *			  with null values like javascript does?
 *
 * HISTORY:
 *		CREATED on 2015-MAR-31 by Daniel Smith dansmith65@gmail.com
 *
 * =====================================
 */

If ( ~jsonFindValue ( json ; keyOrIndex ) ;
	/**
	 * value was found
	 * The pointer stores the starting position of the value.
	 * Get all text before the value & encode the new value & get all text after the value
	 */
	Let ( [
		/**
		 * get text before the value
		 * Offset length by -2 because it is actually pointing at the first
		 * character after the value.
		 */
		~jsonBefore = Middle (
			$~json.text ;
			1 ;
			$~json.at - 2
		) ;
		
		/**
		 * get text after the value
		 * Offset starting point by -1 because it is actually pointing at the second
		 * character after the value.
		 */
		~! = z_jsonParseSupport1 ( 101 /* ParseValueSkip */ ; "" ; "" ; "" ; "" ) ;
		~jsonAfter = If ( IsEmpty ( $~json.error ) ;
			Middle (
				$~json.text ;
				$~json.at - 1 ;
				Length ( $~json.text )
			)
		) ;
		
		~newValue = If ( IsEmpty ( $~json.error ) ;
			If (
				/* return the value as-is if it's a json array or object */
				/**
				 * TODO: this would incorrectly detect json on a value like:
				 *	{this is a note in curly-brances}
				 * TODO: would also fail if there is leading/trailing whitespace
				 */
				Let ( [
					~firstAndLast = Left ( newValue ; 1 ) & Right ( newValue ; 1 )
				] ;
					~firstAndLast = "[]"		/* array */
					or ~firstAndLast = "{}"		/* object */
				) ;
				newValue ;

				~jsonEncodeValue ( newValue )
			)
		)
	] ;
		If ( IsEmpty ( $~json.error ) ;
			~jsonBefore
				& ~newValue
				& ~jsonAfter
			;
			"Error: " & $~json.error
		)
	) ;

	
	/**
	 * value was NOT found
	 */
	Let ( [
		/**
		 * determine if the json is empty: {} or []
		 */
		~isEmpty = If ( IsEmpty ( $~json.error ) ;
			~jsonParseIsEmpty
		) ;
		
		/**
		 * get the position of the last closing bracket
		 */
		~endPosition = If ( IsEmpty ( $~json.error ) ;
			~jsonParseFindEnd ( "" )
		) ;
		
		/**
		 * get text before the closing bracket
		 */
		~jsonBefore =  If ( IsEmpty ( $~json.error ) ;
			Middle (
				$~json.text ;
				1 ;
				$~json.at
			)
		) ;
		
		/**
		 * get closing bracket and all text after it
		 * this will preserver original trailing whitespace
		 */
		~jsonAfter = If ( IsEmpty ( $~json.error ) ;
			Middle (
				$~json.text ;
				$~json.at + 1 ;
				Length ( $~json.text )
			)
		) ;
		
		~newValue = If ( IsEmpty ( $~json.error ) ;
			If (
				/* return the value as-is if it's a json array or object */
				/**
				 * TODO: this would incorrectly detect json on a value like:
				 *	{this is a note in curly-brances}
				 * TODO: would also fail if there is leading/trailing whitespace
				 */
				Let ( [
					~firstAndLast = Left ( newValue ; 1 ) & Right ( newValue ; 1 )
				] ;
					~firstAndLast = "[]"		/* array */
					or ~firstAndLast = "{}"		/* object */
				) ;
				newValue ;

				~jsonEncodeValue ( newValue )
			)
		)
	] ;
		If ( IsEmpty ( $~json.error ) ;
			~jsonBefore
				& If ( not ~isEmpty ; "," )
				& If ( keyOrIndex â‰  GetAsNumber ( keyOrIndex ) ;
					/* keyOrIndex is a string, so assume it's meant to be an object key */
					~jsonEncodeString ( keyOrIndex )
					& ":"
				)
				& ~newValue
				& ~jsonAfter
			;
			"Error: " & $~json.error
		)
	)
)