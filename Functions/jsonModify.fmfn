/**
 * =====================================
 * jsonModify ( json ; keyOrIndex ; newValue )
 *
 * PURPOSE:
 *		Add or modify an object by it's key, or array by it's index.
 *
 * RETURNS:
 *		The modified JSON.
 *
 * PARAMETERS:
 *		json = the json string
 *		keyOrIndex = object property key (name) or array index (position)
 *		newValue = string, number, or a named constant:
 *			json:true, json:false, json:null
 *			should NOT be an object or array (these will be encoded as strings)
 *
 * DEPENDENCIES:
 *		Custom Functions:
 *			z_jsonParseSupport1 - 3
 *			z_jsonEncodeSupport
 *
 * NOTES:
 *
 * TODO:
 *		Determine how to add an array value
 *			- should it allow positional insertion?
 *				- insert before other values
 *					- negative number?
 *					- "unshift" (like the json method) ?
 *				- insert between values
 *					- decimal: 2.5 would insert after 2?
 *				- insert at end
 *					- I assume this would be the most common use-case
 *					- empty keyOrIndex value?
 *			- if the index is higher than array size + 1, should it pad the array
 *			  with null values like javascript does?
 *
 * HISTORY:
 *		CREATED on 2015-MAR-31 by Daniel Smith dansmith65@gmail.com
 *
 * =====================================
 */

Let ( [
	~cache = z_jsonParseSupport1 ( 110 /* GetValuePosition */ ; json ; keyOrIndex ; "" ; "" ) ;
	~newValue = If ( IsEmpty ( $json.error ) ;
		If (
			/* return the value as-is if it's a json array or object */
			/**
			 * TODO: this would incorrectly detect json on a value like:
			 *	{this is a note in curly-brances}
			 * TODO: would also fail if there is leading/trailing whitespace
			 */
			Let ( [
				~firstAndLast = Left ( newValue ; 1 ) & Right ( newValue ; 1 )
			] ;
				~firstAndLast = "[]"		/* array */
				or ~firstAndLast = "{}"		/* object */
			) ;
			newValue ;

			z_jsonEncodeSupport ( 1 /* Value */ ; newValue )
		)
	)
] ;
	Case (
		not IsEmpty ( $json.error ) ;
		"?" ;
		
		/**
		 * value was found
		 */
		~cache ;
		Let ( [
			~cacheAsList = Substitute ( ~cache ; "|" ; Â¶ ) ;
			~valStartPos = GetValue ( ~cacheAsList ; 4 ) ;
			~valEndPos = GetValue ( ~cacheAsList ; 5 ) ;
			~jsonBefore =  Middle (
				json ;
				1 ;
				~valStartPos - 1
			) ;
			~jsonAfter = Middle (
				json ;
				~valEndPos + 1 ;
				Length ( json ) - ~valEndPos + 1
			)
		] ;
			~jsonBefore
				& ~newValue
				& ~jsonAfter
		) ;
		
		
		/**
		 * else: value was NOT found
		 */
		Let ( [
			/**
			 * determine if the json is empty: {} or []
			 */
			~isEmpty = If ( IsEmpty ( $json.error ) ;
				z_jsonParseSupport1 ( 121 /* IsEmpty */ ; json ; "" ; "" ; "" )
			) ;
			
			/**
			 * get the position of the last closing bracket
			 */
			~endPosition = If ( IsEmpty ( $json.error ) ;
				z_jsonParseSupport1 ( 120 /* GetEndPosition */ ; json ; "" ; "" ; "" )
			) ;
			
			/**
			 * get text before the closing bracket
			 */
			~jsonBefore =  If ( IsEmpty ( $json.error ) ;
				Middle (
					json ;
					1 ;
					~endPosition - 1
				)
			) ;
			
			/**
			 * get closing bracket and all text after it
			 * this will preserve original trailing whitespace
			 */
			~jsonAfter = If ( IsEmpty ( $json.error ) ;
				Middle (
					json ;
					~endPosition ;
					Length ( json ) - ~endPosition + 1
				)
			) ;
			
			/**
			 * get closing bracket to determine if it's an object or array
			 */
			~closingBracket = If ( IsEmpty ( $json.error ) ;
				Middle ( json ; ~endPosition ; 1 )
			)
		] ;
			If ( not IsEmpty ( $json.error ) ;
				"?" ;
				
				~jsonBefore
					& If ( not ~isEmpty ; "," )
					& If ( ~closingBracket = "}" /* object */ ;
						z_jsonEncodeSupport ( 2 /* String */ ; keyOrIndex )
						& ":"
					)
					& ~newValue
					& ~jsonAfter
			)
		)
	)
)