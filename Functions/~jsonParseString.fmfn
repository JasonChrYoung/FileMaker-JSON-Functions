/**
 * =====================================
 * ~jsonParseString
 *
 * RETURNS:
 *		FileMaker text (the original value before it was encoded as json).
 *
 * PARAMETERS:
 *		
 *
 * DEPENDENCIES:
 *		Pointer is expected to be at " starting the string.
 *		Custom Functions:
 *			~jsonParseString	(self: it's recursive!)
 *			~jsonParseError
 *			~jsonParseNext
 *			
 *			
 *
 * HISTORY:
 *		CREATED on 2015-MAR-31 by Daniel Smith dansmith65@gmail.com
 *
 * =====================================
 */

Case (
	/* Step 0, set-up */
	not $~jsonParseString.step ;
	Let ( [
		~! = /* logging start disabled LogWriterMemoryCreateEntry (
			"~jsonParseString [step:0]"
		) & disabled logging end */ "" ;
		
		/* currently no setup to do, I'm leaving this structure in case I need it later */
		$~jsonParseString.step = 1
	] ;
		~jsonParseString
	) ;
	
	
	/* Step 1, main */
	$~jsonParseString.step = 1 ;
	Let ( [
		~! = /* logging start disabled LogWriterMemoryCreateEntry (
			"~jsonParseString [step:1]"
				& " [i:" & $~jsonParseString.i & "]"
				& " [result:" & $~jsonParseString.result & "]"
		) & disabled logging end */ "" ;

		~ch = ~jsonParseNext ( "" ) ;
		$~jsonParseString.result =
			Case (
				/* end of string */
				~ch = "\"" ;
				$~jsonParseString.result
					& ~jsonDiscardResult ( ~jsonParseNext ( "" ) )
				;
				
				/* end of json reached before end of string */
				~ch = "" and IsEmpty ( $~json.error ) ;
				~jsonParseError ( "Bad string: reached end of json before end of string" )
				;
				
				/* character is escaped */
				~ch = "\\" ;
				~jsonDiscardResult ( ~jsonParseNext ( "" ) )
					& Case (
						$~json.ch = "u" ;
							$~jsonParseString.result
							& z_jsonParseSupport3 ( 311 /* ParseHex */ ; "" ; "" ; "" ; "" ) ;
						$~json.ch = "\"" ;		$~jsonParseString.result & "\"" ;
						$~json.ch = "\\" ;		$~jsonParseString.result & "\\" ;
						$~json.ch = "/" ;		$~jsonParseString.result & "/" ;
						$~json.ch = "b" ;		$~jsonParseString.result & Char ( 8 ) ;
						$~json.ch = "f" ;		$~jsonParseString.result & Char ( 12 ) ;
						$~json.ch = "n" ;		$~jsonParseString.result & Char ( 10 ) ;
						$~json.ch = "r" ;		$~jsonParseString.result & Char ( 13 ) ;
						$~json.ch = "t" ;		$~jsonParseString.result & Char ( 9 ) ;
						/* else */
						~jsonParseError ( "Bad string: invalid value after backslash escape" )
					)
				;
				
				/* else */
				$~jsonParseString.result & ~ch
			)
		;
		
		$~jsonParseString.i = $~jsonParseString.i + 1 ;
		$~jsonParseString.step = If (
			Not IsEmpty ( $~json.error )		/* an error occurred */
				or IsEmpty ( $~json.ch )		/* no more data left */
				or ~ch = "\""				/* end of string */
			;
			2 ;
			1
		)
	] ;
		~jsonParseString
	) ;

	
	/* Step 2, clean-up and return result */
	$~jsonParseString.step = 2 ;
	Let ( [
		~! = /* logging start disabled LogWriterMemoryCreateEntry (
			"~jsonParseString [step:2]"
				& " [i:" & $~jsonParseString.i & "]"
				& " [result:" & $~jsonParseString.result & "]"
		) & disabled logging end */ "" ;

		~result = $~jsonParseString.result ;
		// purge variables
		$~jsonParseString.i = "" ;
		$~jsonParseString.step = "" ;
		$~jsonParseString.result = ""
	] ;
		~result
	)
)