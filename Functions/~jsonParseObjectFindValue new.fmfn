/**
 * =====================================
 * ~jsonParseObjectFindValue ( key )
 *
 * PURPOSE:
 *		Move pointer to the start of the value for a specified key.
 *
 * RETURNS:
 *		Boolean True if value is found, False if it isn't or if Error.
 *
 * PARAMETERS:
 *		key = object property/name
 *
 * DEPENDENCIES:
 *		The pointer is expected to be on the "{" in the object.
 *
 * HISTORY:
 *		CREATED on 2015-MAR-31 by Daniel Smith dansmith65@gmail.com
 *
 * =====================================
 */

Case (
	/**
	 ***************************************************************************
	 * STEP 0: SET-UP
	 ***************************************************************************
	 */
	not $~jsonParseObjectFindValue.step ;
	Let ( [
		~! = /* logging start disabled LogWriterMemoryCreateEntry (
			"~jsonParseObjectFindValue [step:0]"
				& " [key:" & key & "]"
		) & disabled logging end */ "" ;
		
		/* initialize variable */
		$~jsonParseObjectFindValue.i = 0 ;
		$~jsonParseObjectFindValue.result = "" ;

		~! = If ( IsEmpty ( ~jsonParseNext ( "{" ) ) ;
			~jsonParseError ( "Pointer was not at start of an object" )
		) ;
		
		~! = If ( IsEmpty ( $~json.error ) ;
			~jsonParseWhitespace
		) ;
		
		/* check if object is empty */
		~endFound = If ( IsEmpty ( $~json.error ) ;
			If ( $~json.ch = "}" ;
				True
					& ~jsonDiscardResult ( ~jsonParseNext ( "}" ) )
			)
		) ;
		
		$~jsonParseObjectFindValue.result = Case (
			~endFound ;
			False
		) ;
		$~jsonParseObjectFindValue.step = If (
			not IsEmpty ( $~json.error )
				or not IsEmpty ( $~jsonParseObjectFindValue.result )
			;
			2 ;
			1
		)
	] ;
		~jsonParseObjectFindValue ( key )
	) ;

	
	/**
	 ***************************************************************************
	 * STEP 1: MAIN
	 ***************************************************************************
	 */
	$~jsonParseObjectFindValue.step = 1 ;
	Let ( [
		$~jsonParseObjectFindValue.i = $~jsonParseObjectFindValue.i + 1 ;
		
		~! = /* logging start disabled LogWriterMemoryCreateEntry (
			"~jsonParseObjectFindValue [step:1]"
				& " [key:" & key & "]"
				& " [i:" & $~jsonParseObjectFindValue.i & "]"
		) & disabled logging end */ "" ;
		
		~valueFound = ~jsonParseString = key ;
		
		~! = If ( IsEmpty ( $~json.error ) ;
			~jsonParseWhitespace
		) ;
		
		~! = If ( IsEmpty ( $~json.error ) ;
			~jsonParseNext ( ":" )
		) ;
		
		~! = If ( IsEmpty ( $~json.error ) ;
			~jsonParseWhitespace
		) ;
		
		~! = If ( IsEmpty ( $~json.error ) and not ~valueFound ;
			~jsonParseValueSkip
		) ;
		
		~! = If ( IsEmpty ( $~json.error ) and not ~valueFound ;
			~jsonParseWhitespace
		) ;
		
		/* check if at end of object */
		~endFound = If ( IsEmpty ( $~json.error ) and not ~valueFound ;
			If ( $~json.ch = "}" ;
				True
					& ~jsonDiscardResult ( ~jsonParseNext ( "}" ) )
			)
		) ;
		
		/* advance pointer to start of next key */
		~! = If ( IsEmpty ( $~json.error ) and not ~endFound and not ~valueFound ;
			~jsonParseNext ( "," )
			& If ( IsEmpty ( $~json.error ) ;
				~jsonParseWhitespace
			)
		) ;
		
		$~jsonParseObjectFindValue.result = Case (
			~valueFound ;
			True ;
			
			~endFound ;
			False
		) ;
		$~jsonParseObjectFindValue.step = If (
			not IsEmpty ( $~json.error )
				or not IsEmpty ( $~jsonParseObjectFindValue.result )
			;
			2 ;	/* clean-up */
			1	/* main */
		)
	] ;
		~jsonParseObjectFindValue ( key )
	) ;

	/**
	 ***************************************************************************
	 * STEP 2: CLEAN-UP
	 ***************************************************************************
	 */
	$~jsonParseObjectFindValue.step = 2 ;
	Let ( [
		~result = If ( IsEmpty ( $~json.error ) ;
			$~jsonParseObjectFindValue.result ;
			False
		) ;
		
		~! = /* logging start disabled LogWriterMemoryCreateEntry (
			"~jsonParseObjectFindValue end [i:" & $~jsonParseObjectFindValue.i & "]"
				& " [key:" & key & "]"
				& " [result:" & ~result & "]"
		) & disabled logging end */ "" ;

		// purge variables
		$~jsonParseObjectFindValue.i = "" ;
		$~jsonParseObjectFindValue.step = "" ;
		$~jsonParseObjectFindValue.result = ""
	] ;
		~result
	)
)